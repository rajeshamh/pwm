/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

/*
 * //tim2 ch1 is connected to PA0
 *
 */
#include <stdio.h>
#include <stdint.h>
#include "main.h"

void delay(int n);
void ADC_IRQHANDLER();
/*
 * ARM CORTEX M7 PROCESSOR  NVIC ISER REGISTER
 *
 */
#define NVIC_ISER0		((volatile uint32_t*)0xE000E100U)
#define NVIC_ISER1		((volatile uint32_t*)0xE000E104U)
#define NVIC_ISER2		((volatile uint32_t*)0xE000E108U)
#define NVIC_ISER3		((volatile uint32_t*)0xE000E10cU)

/*
 * ARM CORTEX M7 PROCESSOR  NVIC ICER REGISTER
 *
 */
#define NVIC_ICER0		((volatile uint32_t*)0XE000E180U)
#define NVIC_ICER1		((volatile uint32_t*)0XE000E184U)
#define NVIC_ICER2		((volatile uint32_t*)0XE000E188U)
#define NVIC_ICER3		((volatile uint32_t*)0XE000E18cU)


/*
 * ARM CORTEX M7 PROCESSOR  NVIC IPSR REGISTER
 *
 */

#define NVIC_IPR_BASEADDR		((volatile uint32_t*)0xE000E400U)

#define	NO_PR_BITS_IMPLEMENTED 4

/*
#define SYST_RVR		((volatile uint32_t*) 0xE000E014U)
#define SYST_CVR		((volatile uint32_t*) 0xE000E018U)
*/

uint32_t ADC_BUFF[10];

//************************************** ********************** ******************************8


void gpio_toggle()
{

	GPIOB->BSRR|= 1<<14;
	delay(10);
	GPIOB->BSRR|= 1<<30;



}

void delay(int n)
{

     SysTick->LOAD=16000-1;							//RELOAD VALURE REGISTER
	 SysTick->CURRENT_VAL=0;
	 SysTick->CNTRL=0x5;				    	//ENABLING THE CLOCK AND SELECTING THE CLOCK SOUCRE AS SYSTEM CLOCK

	 for(int i=0;i<n;i++)
	 {
		 while(( SysTick->CNTRL & 0x10000)==0){}	//wait till the counter flag set
	 }

	SysTick->CNTRL=0;								//disable the systick

}

//------------------------------------------------------------------------------------------
void gpio_int()
{


	GPIOA_PERIPH_CLK_EN();		 			 //ENABLE THE PERIPHRAL CLK FOR PORT A
    GPIOA->MODER |= (2<<0);
    GPIOA->AFR[0]|= (1<<0);

    GPIOB_PERIPH_CLK_EN();					 //ENABLE THE PERIPHERAL CLK FOR PORT B
    GPIOB->MODER|=2<<14;					 //ALT FUN MODE
    GPIOB->AFR[0]|=(2<<28);
    GPIOB->MODER|=1<<28;					 //RED USER LED
}


//-------------------------------------------------------------------------------------------------
void tim_init()
{
    //ENABLE THE PERPH CLK FOR TIM4
    TIM4_PERIPH_CLK_EN();

    TIM4->CR1|= ARPE;						  //buffer enable

    TIM4->CCMR1|=6<<12;                 	  //PWM MODE 1 SELECTED
    TIM4->CCMR1|=1<<11;                 		 //PRELOAD ENABLE
    TIM4->CCER|=CCE2_EN;					  //ENABLE CAPTURE COMPARE cH1

   	//PWM Frequency 16000000/1hz =16000000
    //Duty Cycle is determined by the CCRx Value

    TIM4->CNT=0;
    TIM4->PSC=16000-1;
    TIM4->ARR=1000-1;

    TIM4->CCR[1]=500;					     //50% duty cycle

    TIM4->EGR|=UPDATE_GEN;					 //To reinitiaise the buffer

    TIM4->CR1|=TIM_EN; 						 //Enable the timer


}


//-----------------------------------------------------------------------------------------

void ADC_INIT()
{
	TIM2_PERIPH_CLK_EN();					  //ENABLE THE PHP CLK

	TIM2->CCER|=CCE1_EN;					  //ENABLE CAPTURE COMPARE cH1

	TIM2->CR1|= ARPE;						  //buffer enable
	TIM2->CR2|= RESET;						  //RESETTING
	TIM2->CR2|= UPDATE_EVNT;

	TIM2->CCMR1|=PWM_MOD1_EN;                 //PWM MODE 1 SELECTED
	TIM2->CCMR1|=PRELOAR_EN;                  //PRELOAD ENABLE


	//PWM Frequency 16000000/10000 =1600
	//Duty Cycle is determined by the CCRx Value

	TIM2->PSC=16000-1;
	TIM2->ARR=1000-1;

	TIM2->CCR[0]=500-1;

	TIM2->EGR|=UPDATE_GEN;					 //To reinitiaise the buffer
	TIM2->CR1|=TIM_EN; 						 //Enable the timer

	//ADC CH2 is triggered by  PWM OUpUT  EVERY 100US
	//ADC CH2 IS CONNECTED TO PA2
	GPIOA_PERIPH_CLK_EN();					//ENABLE THE PCLK
	GPIOA->MODER|=3<<4;						//SET TO ANALOG MODE

	ADC1_PERIPH_CLK_EN();
	ADC1->CR2|= EXT_TRIG_EN;				//select the external trigger polarity
	ADC1->CR2|= 11<<24;     		        //select the external event used to trigger the start of conversion     TIM2 CH2
	ADC1->SR|=1<<1;
	ADC1->CR1|=1<<5;
    ADC1->SMPR[1]|=	7<<0;                    //SAMPLING TIME   480 CYCLYES
	ADC1->SQR[2] |=	2<<0;					 //SAMPLING SEQUENCE ,CH2 IS SAMPLED FIRST
	ADC1->SQR[0]  =	0X00;					 //NO OF CONVERSION CYCLES IE 1 (LENGTH)
    ADC1->CR2    |= 1<<0;					 //ADC ON

}


void ADC_IRQHandler()
{
	ADC_IRQHANDLER();
}

void ADC_IRQHANDLER()
{
	    uint8_t temp1,temp2;
		temp1=ADC1->CR1 & (1<<5);
		temp2=ADC1->SR & (1<<1);

		if(temp1 && temp2)
		{
			DMA_init(&ADC1->DR,&ADC_BUFF,sizeof(ADC_BUFF));
		}
}





//-------------------------------------------------------------------------------------------

void DMA_init(uint32_t SRC,uint32_t DST,uint32_t LEN)
{
	DMA2_PERIPH_CLK_EN();					//ENABLE THE PERIPHERA CLOCK

	DMA2->S0CR&=~(1<<0);					//DISABLE THE DMA STREAM

	DMA2->LIFCR|=(0<<18)|(0<<19)|(0<<20)|(0<<21); //CLEAR THE INTERRPT FLAGS

	DMA2->S0CR|=TCIE;						//transfer complete interrupt enable

	DMA2->S0CR|=MINC; 						//MEMORY INCREMENT

	DMA2->S0CR|=PINC;						// peripheral increment mode

	DMA2->S0CR|=CIRC;						//CIRCULAR MODE ENABLED

	DMA2->S0CR|=DIR;						//data transfer direction

	DMA2->S0PAR=SRC;						//Base address of the peripheral data register from/to which the data is read/written.

	DMA2->S0M0AR=DST;						//Base address of memory area 0 from/to which the data is read/written.

	DMA2->S0NDTR=LEN;						// number of data items to transfer

	DMA2->S0CR|=CHSEL;						// channel selection

	DMA2->S0CR|=TCIE;						//: transfer complete interrupt enable

    DMA2->S0FCR|=DMDIS;						// direct mode enabled

    DMA2->S0CR|=EN;							//stream enable

    ADC1->CR2|= DMA_MODE_ON;

}



void Interrupt_CONFIG(uint8_t IRQNO,uint8_t STATUS)
{

	if(STATUS==ENABLE)
	{
		if(IRQNO<=31)
		{
			//PROGRAM THE ISRE0 REGISTER
			*NVIC_ISER0|=1<<IRQNO;
		}
		else if(IRQNO>=32 && IRQNO<63)
		{

			//PROGRAM THE ISRE1 REGISTER
			*NVIC_ISER1|=1<<(IRQNO % 32);
		}
		else if(IRQNO>=64 && IRQNO<96)
		{
			//PROGRAM THE ISRE2 REGISTER
			*NVIC_ISER2|=1<<(IRQNO % 64);
		}

	}
	else
		{

		if(IRQNO<=31)
		{
			//PROGRAM THE ISRE0 REGISTER
			*NVIC_ICER0|=1<<IRQNO;
		}
		else if(IRQNO>=32 && IRQNO<63)
		{

			//PROGRAM THE ISRE1 REGISTER
			*NVIC_ICER1|=1<<(IRQNO%32);
		}
		else if(IRQNO>=64 && IRQNO<96)
		{
			//PROGRAM THE ISRE2 REGISTER
			*NVIC_ICER2|=1<<(IRQNO%64);
		}



     }
}

void DMA_IRQ_Priority_HANDLE(uint8_t IRQNO,uint8_t Priority)
{
	uint8_t iprx = IRQNO/4;						//REGISTER SELECTION
	uint8_t iprx_selection=IRQNO%4;				//BIT SELECTION

	uint8_t shift_amout=(8*iprx_selection)+(8-NO_PR_BITS_IMPLEMENTED);

	*(NVIC_IPR_BASEADDR + (iprx*4) )|=Priority<<shift_amout;
}


void DMA_IRQHandling()
{
	    uint8_t temp1,temp2;
		temp1=DMA2->LISR & TCIF;
		temp2=DMA2->S0CR & TCIE;

		if(temp1 && temp2)
		{

            int i=0;
			DMA2->LIFCR|= 1<<5;						//Writing 1 to this bit clears the corresponding TCIFx flag in the DMA_LISR register
			//ADC_BUFF[i++]=ADC1->DR;
			gpio_toggle();

		}
}
void DMA2_Stream0_IRQHandler()
{
	DMA_IRQHandling();


}


//--------------------------------------------------------------------------------------

int main()
{
	gpio_int();
	tim_init();

	Interrupt_CONFIG(18,ENABLE);
    Interrupt_CONFIG(56,ENABLE);


    ADC_INIT();
  //  DMA_init(&ADC1->DR,&ADC_BUFF,sizeof(ADC_BUFF));
    ADC1->CR2|=SWSTART;


	while(1)
	{

	}





}




















